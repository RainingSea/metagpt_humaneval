{"task_id": "HumanEval/0", "completion": "import numpy as np\nfrom typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    _numbers = np.array(numbers)\n    _threshold = threshold\n    sorted_numbers = np.sort(_numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) <= _threshold:\n            return True\n    return False"}
{"task_id": "HumanEval/1", "completion": "def separate(paren_string: str) -> list[str]:\n        stack = []\n        groups = []\n        for char in paren_string:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if stack and stack[-1] == '(':\n                    if stack:\n                        stack.pop()\n                    if not stack or stack[-1] != '(':\n                        if stack:\n                            groups.append(\"\".join( stack))\n                            stack.clear()\n                else:\n                    # Handle unbalanced right parenthesis by starting a new group\n                    if stack:\n                        groups.append(\"\".join( stack))\n                        stack.clear()\n                    stack.append(char)\n            else:\n                if stack:\n                    stack.append(char)\n\n        # Handle any unbalanced parentheses remaining in the stack\n        if stack:\n            groups.append(\"\".join(stack))\n            stack.clear()\n\n        return groups\n"}
{"task_id": "HumanEval/2", "completion": "def truncate_number(number: float) -> float:\n    \"\"\"\n    This function takes a floating point number and returns its decimal part.\n    \n    Args:\n    number (float): The floating point number to be truncated.\n    \n    Returns:\n    float: The decimal part of the number.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Negative numbers are not supported.\")\n    \n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part"}
{"task_id": "HumanEval/3", "completion": "def below_zero(transactions: list) -> bool:\n    initial_balance = 0\n    current_balance = initial_balance\n    for transaction in transactions:\n        current_balance = transaction + current_balance\n        if current_balance < 0:\n            return True\n    return False\n"}
{"task_id": "HumanEval/4", "completion": "import numpy as np\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the Mean Absolute Deviation (MAD) of a list of numbers.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    float: The Mean Absolute Deviation of the numbers.\n\n    Raises:\n    ValueError: If the input is not a list or contains non-numeric values.\n    \"\"\"\n\n    # Validate the input\n    if not isinstance(numbers, list):\n        raise ValueError(\"Input must be a list of numbers.\")\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty.\")\n    if not all(isinstance(n, (int, float)) for n in numbers):\n        raise ValueError(\"All elements in the input list must be numeric.\")\n\n    # Convert the list to a NumPy array for efficient computation\n    np_numbers = np.array(numbers)\n\n    # Calculate the mean of the numbers\n    mean_value = np.mean(np_numbers)\n\n    # Calculate the absolute differences from the mean\n    abs_differences = np.abs(np_numbers - mean_value)\n\n    # Calculate the mean of the absolute differences\n    mad_value = np.mean(abs_differences)\n\n    return mad_value\n"}
{"task_id": "HumanEval/5", "completion": "from typing import List\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \n    if not numbers:  \n        return []\n    interspersed_list = [numbers[0]]\n    for number in numbers[1:]:\n        interspersed_list.append(delimiter)  \n        interspersed_list.append(number)     \n\n    return interspersed_list\n"}
{"task_id": "HumanEval/6", "completion": "def parse_nested_parens(paren_string: str) -> list[int]:\n    \"\"\"\n    Parses a string containing nested parentheses and returns a list of integers\n    representing the nesting levels of each parenthesis.\n\n    :param paren_string: A string containing only parentheses.\n    :return: A list of integers representing the nesting levels.\n    \"\"\"\n    nesting_levels_list = []\n    level = 0\n\n    for char in paren_string:\n        if char == '(':\n            level += 1\n            nesting_levels_list.append(level)\n        elif char == ')':\n            nesting_levels_list.append(level)\n            level -= 1\n            if level < 0:\n                raise ValueError(\"Unmatched closing parenthesis detected.\")\n\n    if level != 0:\n        raise ValueError(\"Unmatched opening parenthesis detected.\")\n\n    return nesting_levels_list"}
{"task_id": "HumanEval/7", "completion": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"\n    Filters a list of strings and returns only those that contain the given substring.\n\n    Args:\n        strings (List[str]): The list of strings to filter.\n        substring (str): The substring to search for within the strings list.\n\n    Returns:\n        List[str]: A list of strings that contain the substring.\n    \"\"\"\n    filtered_strings = [s for s in strings if substring in s]\n    return filtered_strings"}
{"task_id": "HumanEval/8", "completion": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Calculate the sum and product of a list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    Tuple[int, int]: A tuple containing the sum and product of the list.\n    \"\"\"\n    if not numbers:  # Handle empty list\n        return 0, 0\n\n    total_sum = sum(numbers)\n    total_product = 1\n    for number in numbers:\n        total_product *= number\n\n    return total_sum, total_product\n"}
{"task_id": "HumanEval/9", "completion": "from collections import deque\nfrom typing import List\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    window = deque(maxlen=4)\n    if not numbers:\n        return []\n    max_values = []\n    for i, number in enumerate(numbers):\n        # Append the new number to the right side of the deque\n        window.append(number)\n        # When the window is fully filled for the first time\n        if i >= window.maxlen - 1:\n            # Compute the current maximum and append it to the result list\n            max_values.append(max(window))\n    return max_values"}
{"task_id": "HumanEval/10", "completion": "## palindrome.py\n\nfrom typing import Optional\n\ndef make_palindrome(string: str, center: Optional[str] = None) -> str:\n    \"\"\"\n    Create a palindrome by appending characters to the end of the string.\n\n    Args:\n    string (str): The base string to create a palindrome from.\n    center (Optional[str]): A center string to be placed in the middle of the palindrome. Default is None.\n\n    Returns:\n    str: A palindrome string.\n    \"\"\"\n    # Remove spaces and convert to lowercase for uniformity\n    cleaned_string = ''.join(char.lower() for char in string if char.isalnum())\n    # Reverse the cleaned string except for the last character\n    reversed_string = cleaned_string[:-1][::-1]\n    # Create palindrome by combining the original string, optional center, and the reversed string\n    palindrome = cleaned_string + (center or '') + reversed_string\n    return palindrome\n\n"}
{"task_id": "HumanEval/11", "completion": "from typing import Callable\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"\n    Perform a binary XOR operation on two strings.\n\n    Args:\n    a (str): The first binary string.\n    b (str): The second binary string.\n\n    Returns:\n    str: The result of the binary XOR operation.\n    \"\"\"\n    # Ensure both strings are of the same length\n    max_length = max(len(a), len(b))\n    a = a.zfill(max_length)\n    b = b.zfill(max_length)\n\n    # Perform XOR operation\n    result = ''.join('1' if bit_a != bit_b else '0' for bit_a, bit_b in zip(a, b))\n    return result"}
{"task_id": "HumanEval/12", "completion": "## longest_string_finder.py\n\nfrom typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"\n    Find the longest string in a list of strings.\n\n    Args:\n    strings (List[str]): A list of strings.\n\n    Returns:\n    Optional[str]: The longest string, or None if the list is empty.\n    \"\"\"\n    if not strings:  # Check if the list is empty\n        return None\n\n    longest_string = strings[0]\n    max_length = len(longest_string)\n\n    for string in strings[1:]:\n        if len(string) > max_length:\n            longest_string = string\n            max_length = len(string)\n\n    return longest_string\n"}
{"task_id": "HumanEval/13", "completion": "from typing import Tuple\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n\n    Args:\n        a (int): First number.\n        b (int): Second number.\n\n    Returns:\n        int: The greatest common divisor of a and b.\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a"}
{"task_id": "HumanEval/14", "completion": "from typing import List\n\ndef all_prefixes(input_string: str) -> List[str]:\n    \"\"\"\n    Extracts all prefixes from the given input string.\n\n    Args:\n    input_string (str): The string from which to extract prefixes.\n\n    Returns:\n    List[str]: A list containing all the prefixes of the input string.\n    \"\"\"\n    return [input_string[:i] for i in range(1, len(input_string) + 1)]"}
{"task_id": "HumanEval/1", "completion": "def separate(paren_string: str) -> list[str]:\n        stack = []\n        groups = []\n        for char in paren_string:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if stack and stack[-1] == '(':\n                    if stack:\n                        stack.pop()\n                    if not stack or stack[-1] != '(':\n                        if stack:\n                            groups.append(\"\".join( stack))\n                            stack.clear()\n                else:\n                    # Handle unbalanced right parenthesis by starting a new group\n                    if stack:\n                        groups.append(\"\".join( stack))\n                        stack.clear()\n                    stack.append(char)\n            else:\n                if stack:\n                    stack.append(char)\n\n        # Handle any unbalanced parentheses remaining in the stack\n        if stack:\n            groups.append(\"\".join(stack))\n            stack.clear()\n\n        return groups\n"}
{"task_id": "HumanEval/1", "completion": "from typing import List\ndef separate(paren_string) -> List[str]:\n        stack = []\n        groups = []\n        for char in paren_string:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if stack and stack[-1] == '(':\n                    if stack:\n                        stack.pop()\n                    if not stack or stack[-1] != '(':\n                        if stack:\n                            groups.append(\"\".join( stack))\n                            stack.clear()\n                else:\n                    # Handle unbalanced right parenthesis by starting a new group\n                    if stack:\n                        groups.append(\"\".join( stack))\n                        stack.clear()\n                    stack.append(char)\n            else:\n                if stack:\n                    stack.append(char)\n\n        # Handle any unbalanced parentheses remaining in the stack\n        if stack:\n            groups.append(\"\".join(stack))\n            stack.clear()\n\n        return groups\n"}
